# Notes

## [Chapter 2: Program Structure](https://eloquentjavascript.net/3rd_edition/02_program_structure.html)

*All content paraphrased from the above link.*

- This chapter introduces concepts that are linked to programming.
- ***Expressions and Statements***
  - Chapter 1 introduced values and operation application to make new values, but needs additional functionality to be of use.
  - Code that makes a value is known as an *expression* - this includes literal values, like a string or number; those included in parentheses; or unary or binary operators applied to their respective expressions. This structure is similar to human language, where you can have multiple subsentences within each other.
  - Continuing to build on this analogy, a full sentence is called a *statement*. JavaScript programs are lists of statements. The most concise statement is any expression that ends with a semicolon. However, these can often add no value to a program, especially if they stand alone. They only bring value if it causes a change, or *side effect*.
  - Sometimes JavaScript allows no semicolon; other times, it will be necessary to differentiate statements. Since not including semicolons can cause problems, it's best to include them at the end of all statements until the user has a better understanding of them. 
- ***Bindings***
  - The previous chapter only discussed old values and how to create new ones from old ones. A few concerns to be aware of based on current knowledge:
    - Old values can't be changed once defined.
    - New values have to be used after being made or will vanish.
  - This issue is resolved through *bindings*, also known as *variables*. The binding's structure starts with a keyword, `let`; the binding's name; and the optional immediate value that's set with an equal sign and the value. Bindings' names can be used as expressions, where the value is the current value. This value can always change by using the equal sign with the new value.
  - The author compares bindings to tentacles as they only grasp, not contain, values. (Note two individual bindings can actually be equal to the same value.)
  - Programs can only access values it still can reference.
  - Bindings without values hold nothing, so empty bindings will be see as `undefined` until they equal something.
  - You can define multiple bindings with a single `let` statement, but the values need to be separated by commas.
  - Additional keywords to define bindings are `var` (the way variables were created up to 2015 - more details on the difference will come later, but it's best to still with `let`) and `const` (short for *constant*, which remains the same).
- ***Binding Names***
  - Mostly anything can be used as a name, with a few exceptions:
    - It cannot start with numbers.
    - The only symbols that can be used are dollar signs ($) and underscores (_).
    - Certain words cannot be used as binding names as they're saved for specific functions in JavaScript. The author lists all the reserved keywords, as seen below:
      - `break case catch class const continue debugger default delete do else enum export extends false finally for function if implements import interface in instanceof let new package private protected public return static super switch this throw true try typeof var void while with yield`
    - He mentions to potentially look out if errors occur because a reserved keyword is being used.
- ***The Environment***
  - The *environment* is all bindings and values that exist during a current time. Even if no created bindings exist, there are other ones that exist within the system.
- ***Functions***
  - Many values have a type known as *function*, or a program that's wrapped in a value. The value that encases the program can then be applied to have the program run. The example used by the author is the binding prompt, which has a function holding a dialog box asking for user input.
    - `prompt() //The text goes inside of the parentheses with quotation marks` 
  - When a function runs, it's known as invoking; calling; or applying. Functions can run after you include parentheses after including an expression, and usually use the binding name. The information used in functions are known as *arguments*. Depending on the function, different numbers or arguments may be needed.
  - The above function is not used often in modern web programming unless you're testing or making toy programs.
- ***The console.log() Function***
  - The function used in book examples to show text was `console.log()`. JavaScript and its variant languages have this function that prints out the input to another device (i.e. browsers show output on the console, which can be shown through its Developer Tools option). Unlike the example included, the output of the program is shown after the example.
  - The `console.log` name includes a period because it is a binding known as `console` that finds a `log` property. This is further discussed in Chapter 4 and this syntax is not allowed for regular bindings.
- ***Return Values***
  - Things that are shown or happen are known as *side effects*, which can be helpful.
    - Example: `console.log(Math.max(2,4)) \\returns largest value`
  - The value that is ultimately shown is *returned*.
  - Chapter 3 will go more into creating our own functions.
- ***Control Flow***
  - Statements are executed from the top to the bottom.
  - The author provides the below example of a *straight-line control flow* program:
    - `let theNumber = Number(prompt("Pick a number"));
    - console.log("Your number is the square root of " + theNumber * theNumber);`
- ***Conditional Execution***
  - *Conditional execution* happens when conditions are associated with the action a program should take. These are determined with the reserved keyword *if*. Input that doesn't meet the conditions of a program will be ignored and unexecuted, which is defined after using `if`, where the condition is between parentheses and the item the program should execute.
  - A predefined function in JavaScript is `Number.isNan`, which is only true when arguments are `NaN` and strings aren't real numbers.
  - You can use either brackets, {}, or parentheses to include more than one statement. Many of the examples will include these except a few examples where one-liners may be included on the same line (an example from the text is included below):
    - `if (1 + 1 == 2) console.log("It's true");`
  - Code will usually include code for both true conditions and the other cases. These follow after the initial condition. These can be added on using if (first case); else (only one additional case); and else if (multiple additional cases). He includes additional examples below (the first is pulled from the text, the second is modified ((outputs)) and happens when you have multiple paths):
    - First Example
      - `let theNumber = Number(prompt("Pick a number"));`
      - `if (!Number.isNan(theNumber)) {`
        - `console.log("Your number is the square root of " + theNumber * theNumber);`
      - `} else {`
        - `console.log("Hey. Why didn't you give me a number?;`
      - `}`
    - Second Example (Asks the user to input a number and outputs a different message depending on the value the user provides.)
      - `let num = Number(prompt("Pick a number"));`
      - `if (num < 0) {`
        - `console.log("Negative");`
      - `else if (num > 0) {`
        - `console.log("Positive");`
      - `else {`
        - `console.log("NaN");`
- ***While and Do Loops***
  - What happens if you want a program that prints a series of numbers, like the even numbers between 0 to 12? You could use the `console.log` function for each number, but it wouldn't be efficient, especially if you need to work with a larger number set. A better alternative would be a *loop*, which runs a piece of code a few times. This also allows us to go back to a previous point in the program and take the same action with the current program's state. He shows a potential solution to the previous problem below:
    - `let number = 0;`
    - `while (number <= 12) {`
    - `  console.log(number);`
    - `  number = number + 2;`
    - `}`
  - Any code defined after the predefined keyword `while` ensures code can be looped. As seen in the above example, it's similar to the `if` loop since the structure has parentheses with an enclosing expression and a statement. The statement continues to run if the value produced by the expression converts to a `true` Boolean value.
  - Another point to note is how the `number` binding can keep track of the program's progress. This value gets updated every time the loop runs and is compared to 12 (the defined number) to see if the program still needs to run.
  - Now that we understand the basics of the `while` loop, we can easily use it to build other mathematical programs, like the one below that calculates 2 to the 10th power. This one uses two bindings for the answer and a counter to see how much it's been multipled by 2 (the bindings get updated if the answer hasn't be reached yet):
    - `let result = 1;`
    - `let counter = 0;`
    - ` while (counter < 10) {`
    -   `result = result * 2;`
    -   `counter = counter + 1;`
    - `}`
    - `console.log(result);`
  - The author points out that the counter could start at 1 and continued until it was less than or equal to 10, but mentions it's better to start at 0 and covered in Chapter 4.
- Another way to repeat code is by using the `do` loop, which always executes code at least one time and tests whether it will stop only after the code runs the first time. The testing condition appears after the body's loop, seen in the example below (forces the user to write a name until the string isn't empty; the use of the `!` operator converts the value to a Boolean before having it become negated):
  - `let yourName;`
  - `do {`
    - `yourName = prompt("Who are you?");`
    - `} while(!yourName);`
    - `console.log(yourName);`
- ***Identing Code***
  - The author comments that in previous examples, he added spaces before some statements that are included in programs that have functions. He mentions these are optional and users could easily write the code without them or linebreaks if they wished. The purpose of including these spaces is to make it easier to find specific statements. The specific number of spacing doesn't matter as long as it's consistent with each function declaration. Many programming editors automatically do this.
- ***For Loops***
  - Loops usually are similar to what's shown in `while` - create a counter binder for progress tracking; a `while` loop to see if the counter has reached the end; and updating the counter after it has finished checking. This is why many languages, including JavaScript, have made a concise loop, `for`:
    - `for (let number = 0; number <= 12; number = number + 2) {`
      - `console.log(number);`
    - `}`;
  - This example is similar to the loop that printed even numbers except that the loop statements are included after declaring `for`.
  - Note that conditions included in the () of `for` need to include the `;` to separate the loop initialization; the condition that checks if the loop repeats; and whether the loop updates. An updated example of 2 raised to the 10th power is included below using `while`:
    - `let result = 1;`
    - `for (let counter = 0; counter < 10; counter = counter + 1) {`
      - ` result = result * 2;`
    - `}`
    - `console.log(result);`
- ***Breaking Out of a Loop***
  - The only way to do this based on how the loop works is when the condition is false. Otherwise, the `break` statement can be used to get out of the loop instantaneously. An example is included below, where the code gets out of the loop for the first number that's divisible by 7 and greater than or equal to 20 (the number would be 21).
    - `for (let current = 20; ; current = current+1) {`
    -   `if (current % 7 == 0) {`
      - `console.log(current);`
      - `break;`
      - `}`
    - `}`
  - `}`
  - The remainder operator, used in the program, is `%`, and helps test whether a number is divisible by another.
  - Note that the second condition is blank, so the loop continues until the `break` runs. Since the former doesn't include a condition, and if the break statement wasn't included in the program, it would be stuck in an *infinite loop* and never stop running.
  - A similar keyword to `break` is `continue`, which jumps out of the body code and goes into the next looping of code.
- ***Updating Bindings Succinctly***
  - There's a shorthand way to update bindings. Previous examples have shown this as `counter = counter + 1;` but can instead be written as `counter += 1;`. Note this can be used for the `*` and `-` operators as well. Similarly, `counter += 1` and `counter -= 1` can be written as `counter++` and `counter--`, respectively.
- ***Dispatching On A Value with Switch***
  - Some code will have multiple `else if` statements, as seen below:
    - `if (x == "value1") action1();`
    - `else if (x == "value2") action2();`
    - `else is (x == "value3") action3();`
    - `else defaultAction();`
  - The same code can be expressed more directly using a construct, `switch`, even if it seems more awkward (its structure is based on the way it's written in C and Java):
    - `switch (prompt("What is the weather like?")) {`
      - `case "rainy":`
        - `console.log("Remember to bring an umbrella.");`
        - `break;`
      - `case "sunny":`
        - `console.log("Dress lightly.");`
      - `case "cloudy":`
        - `console.log("Go outside.");`
        - `break;`
      - `default:`
        - `console.log("Unknown weather type!");`
        - `break;`
      - `}`
    - There's no limit to `case` values that can be included within the brackets. The initial value that will be shown is either the assigned `switch` value or `default` is nothing is found and continues executing until `break` is reached. Some code might be shared within cases, such as the sunny and cloudy cases going outside. The author warns to be mindful of forgetting breaks and causing the program to execute unwanted code.
- ***Capitalization***
    - When it comes to naming variables, it's normal to use multiple words to describe it. The following three styles are common naming conventions:
      - `myfirstvariable` (can potentially be hard to read)
      - `my_first_variable` (clearer to read but the author points out it may potentially be a nuisance to type out)
      - `MyFirstVariable`
      - `myFirstVariable` (functions and most programmers write their variables like this)
    - Sometimes (including the previously used Number function) the first word uses capitalization to let those viewing the code that it is a constructor (later defined in Chapter 6).
- ***Comments***
  - Whether your code's context is not clear enough when read alone, or if you want to add on some other notes about what is it or does, you can add *comments*, lines of text that the program ignores and doesn't execute.
  - There are two ways to comment code: using the single line version, `//`, or the multi-line one, `/* */`, in case it expands longer than a single line.
- ***Summary***
  - Programs are built on statements, which can also include substatements within, and expressions, which can have subexpressions.
  - Statements included in a top-down order are executed in this manner. In order to change the control flow of the program, you can use `if`, `else`, or `switch` conditions and `while, do, for` loops.
  - Bindings can be used to save data for future use or to track a state. If someone refer to an environment, it means the bindings that have already been defined. JavaScript includes a default value of these bindings for your convenience.
  - Functions enclose parts of your program and can be called by including the function's name, along with its arguments, in parentheses (`functionName(argumentN, argumentN-1). This expression might produce a value, but may not always do so.
- ***Exercises***
  - To put our JavaScript knowledge to the test, the author includes exercises. My solutions can be seen in the previous directory under similar names of the following sections:
    - ***Looping a Triangle***
      - Loop the console.log function seven times to produce a triangle seen below:
        - `#`
        - `##`
        - `###`
        - `####`
        - `#####`
        - `######`
        - `#######`
      - He provides a helpful hint in case the length of the string needs to be checked by using `.length`. 
    - ***FizzBuzz***
      - Use `console.log` to print numbers from 1 to 100 except for the following cases:
        - Print `"Fizz"` instead of a number when it's divisible by 3, and `"Buzz"` when it is divisible by 5 only.
        - Once these are correctly functioning, modify the program so `"FizzBuzz"` displays on numbers divisible by both 3 and 5. x
    - ***Chessboard***
      - The program should output strings that look like a chessboard, separating lines with the newline character. The grid should have either a space or a hash (example included below). Once this initial program works, define a binding, `size`, with the value 8 so it can work for a "chessboard" of any size.   
      - `# # # #`
      - ` # # # # `
      -  `# # # #`
      -  `# # # # `
      -   `# # # #`
      -   `# # # # `
      -   `# # # #`
      -   `# # # #`
